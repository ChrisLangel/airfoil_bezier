#!/usr/bin/python
import wx
import matplotlib
matplotlib.use('WXAgg')
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.backends.backend_wx    import NavigationToolbar2Wx
from subprocess                        import Popen
from matplotlib.figure                 import Figure
import numpy, os
from bezier_funcs                      import *
import subprocess as sp
import shutil
import sys
import string
import time

matplotlib.rcParams.update({'font.size': 20})
# ------------------------------------------------------------------------
# Window that displays plots
# ------------------------------------------------------------------------

class plotwindow(wx.Frame):
    def __init__(self, parent):
        wx.Frame.__init__ ( self, parent, id = wx.ID_ANY, title = "Bezier Airfoil Smoother", pos = wx.DefaultPosition, size = wx.Size( 800,500 ), style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL )
#        self.Parent = parent
        self.movecp = False
        self.pointsel = False
        self.Bind(wx.EVT_CLOSE, self.on_close)

        # Default figure size, this is part of the frame so when exiting,
        # the figure does no go away, the frame is just hidden
        self.fig = Figure(figsize = (14,7), dpi=80)
        self.fig.subplots_adjust(bottom=0.11)
        self.fig.subplots_adjust(top=0.95)
        self.fig.subplots_adjust(right=0.95)
        self.fig.subplots_adjust(left=0.08)
        self.fig.subplots_adjust(wspace=0.15)
        self.axes = self.fig.add_subplot(111)

        # Use canvas to embed figure in frame
        self.canvas = FigureCanvas(self, -1, self.fig)
        self.sizer = wx.BoxSizer(wx.VERTICAL)
        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)
        # connect mouse events to functions  
        self.fig.canvas.mpl_connect('button_press_event', self.on_pick)
        self.fig.canvas.mpl_connect('scroll_event', self.on_scroll)
        self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion )
        self.fig.canvas.mpl_connect('button_release_event', self.on_release)
        self.add_toolbar()  # comment this out for no matplotlib toolbar

        self.SetSizer(self.sizer)
        self.Fit()
        #self.Layout()


# ----------------------------------------------------------------------
#   Adds standard matplotlib toolbar to frame
# ----------------------------------------------------------------------

    def add_toolbar(self):
        self.toolbar = NavigationToolbar2Wx(self.canvas)
        self.toolbar.Realize()
        if wx.Platform == '__WXMAC__':
            # Mac platform (OSX 10.3, MacPython) does not seem to cope with
            # having a toolbar in a sizer. This work-around gets the buttons
            # back, but at the expense of having the toolbar at the top
            self.SetToolBar(self.toolbar)
        else:
            # On Windows platform, default window size is incorrect, so set
            # toolbar width to figure width.
            tw, th = self.toolbar.GetSizeTuple()
            fw, fh = self.canvas.GetSizeTuple()
            # By adding toolbar in sizer, we are able to put it at the bottom
            # of the frame - so appearance is closer to GTK version.
            # As noted above, doesn't work for Mac.
            self.toolbar.SetSize(wx.Size(fw, th))
            self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)
        # update the axes menu on the toolbar
        self.toolbar.update()


# ------------------------------------------------------------------------
# Function that is called when mouse is clicked on figure
# ------------------------------------------------------------------------

    def on_pick( self, event ):
        # see what button is pushed
        if event.button == 1:    # Left mouse button
            self.on_leftclick(event)
        elif event.button == 3:  # Right mouse button
            self.on_rightclick(event)

# ------------------------------------------------------------------------
# Function that will zoom in and out using mouse wheel
# ------------------------------------------------------------------------

    def on_scroll( self, event ):
        scale = 1.15 # How fast we want to zoom in and out
        if event.button == 'down':
            factor = 1/scale
        elif event.button == 'up':
            factor = scale

        curr_xlim = self.axes.get_xlim()
        curr_ylim = self.axes.get_ylim()

        new_width = (curr_xlim[1]-curr_xlim[0])*factor
        new_height= (curr_ylim[1]-curr_ylim[0])*factor

        relx = (curr_xlim[1]-event.xdata)/(curr_xlim[1]-curr_xlim[0])
        rely = (curr_ylim[1]-event.ydata)/(curr_ylim[1]-curr_ylim[0])

        self.axes.set_xlim([event.xdata-new_width*(1-relx),
                    event.xdata+new_width*(relx)])
        self.axes.set_ylim([event.ydata-new_height*(1-rely),
                    event.ydata+new_height*(rely)])
        self.canvas.draw()



    def on_rightclick( self, event ):
        ''' 
            Function that will find closest point to right click 
        '''
        x,y = event.xdata, event.ydata
        if self.parent.havefile:
            xus,yus = self.parent.xu, self.parent.yu
            xls,yls = self.parent.xl, self.parent.yl
            minup = 9999.0
            for i in range(len(xus)):
                dist = ( (xus[i] - x)**2 + (yus[i] - y)**2)**0.5
                if dist < minup:
                    minup = dist
                    inup = i
            minl = 9999.0
            for i in range(len(xls)):
                dist = ( (xls[i] - x)**2 + (yls[i] - y)**2)**0.5
                if dist < minl:
                    minl = dist
                    inl = i
            if self.pointsel:
                del self.axes.lines[self.ponind]
            if minup < minl: # we are on upper surface
                self.axes.plot(xus[inup],yus[inup],'r*',ms=10)
                self.parent.weight.SetValue( self.parent.wtu[inup])
                self.pind   = inup
                self.u_or_l = 'u'
            else:
                self.axes.plot(xls[inl],yls[inl],'r*', ms=10)
                self.parent.weight.SetValue( self.parent.wtl[inl])
                self.pind   = inl
                self.u_or_l = 'l'
            self.pointsel = True
            self.canvas.draw()
            self.ponind   = len( self.axes.lines ) - 1

# ------------------------------------------------------------------------
# Function that will find closest control point
# ------------------------------------------------------------------------

    def on_leftclick( self, event ):
        x,y = event.xdata, event.ydata
        if (self.parent.canrs and self.parent.cpshown):
            xus,yus = self.parent.xcu, self.parent.ycu
            xls,yls = self.parent.xcl, self.parent.ycl
            minup = 9999.0
            for i in range(len(xus)):
                dist = ( (xus[i] - x)**2 + (yus[i] - y)**2)**0.5
                if dist < minup:
                    minup = dist
                    inup = i
            minl = 9999.0
            for i in range(len(xls)):
                dist = ( (xls[i] - x)**2 + (yls[i] - y)**2)**0.5
                if dist < minl:
                    minl = dist
                    inl = i

            if minup < minl: # we are on upper surface
                self.cpind = inup 
                self.u_or_l = 'u'                      
            else:
                self.cpind = inl
                self.u_or_l = 'l'     
            if (minup < 0.04 or minl < 0.04 ):
                self.movecp = True
            
# ------------------------------------------------------------------------
# Functions that will move control point on drag
# ------------------------------------------------------------------------
    def on_motion( self,event ):
        if self.movecp:
	    if self.pointsel:
	        # Wipe out the point selected
	        self.parent.cpcurves.append( self.ponind )
                self.parent.cpcurves.sort()
                self.parent.cpcurves.reverse()
	        self.pointsel = False
            self.parent.del_cpts()
            self.parent.cpshown = False
            if self.u_or_l == 'u':
                if self.cpind == 1 or self.cpind == len(self.parent.Poutu[1])-1:
                   self.parent.Poutu[1][self.cpind] = event.ydata 
                else: 
                   self.parent.Poutu[0][self.cpind] = event.xdata 
                   self.parent.Poutu[1][self.cpind] = event.ydata 
            else:
                if self.cpind == 1 or self.cpind == len(self.parent.Poutl[1])-1:
                    self.parent.Poutl[1][self.cpind] = event.ydata  
                else:
                    self.parent.Poutl[0][self.cpind] = event.xdata
                    self.parent.Poutl[1][self.cpind] = event.ydata
            self.parent.show_cpts( event )

    def on_release( self,event ):
        if self.movecp:
        # this bit of code redraws the bezier curve after moving a control point
            self.parent.itopt  = 0
            self.parent.redraw = True
            self.parent.gen_bez( event )
        self.movecp = False

    def showwin( self, event ):
        self.canvas.draw()

    def on_close( self, event ):
        self.Hide()


class PlotWindow(plotwindow):
      def __init__(self, parent):
        plotwindow.__init__(self, parent)
        self.parent = parent

############################################################################
class PointDistribution( wx.Frame ):
    def __init__( self, parent ):
        wx.Frame.__init__ ( self, parent, id = wx.ID_ANY, title = "Point Diststribution", pos = wx.DefaultPosition, size = wx.Size( 380,600 ), style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL )
        self.Bind(wx.EVT_CLOSE, self.on_close)
        BoxSizer01 = wx.BoxSizer( wx.VERTICAL )        
        self.text0 = wx.StaticText(self,-1,label='------------ Choose point distribution for curves -------------')
        self.check_auto = wx.CheckBox(self, -1, label = 'Constant Spacing')
        self.check_clust = wx.CheckBox(self, -1, label = 'Cluster Leading/Trailing Edge')
        
        self.pctple = wx.SpinCtrl( self, -1, min=5,max=40, initial=20, size = (45,-1))
        self.text1 = wx.StaticText(self,-1,label='% of points clustered in leading')
        self.pctled = wx.SpinCtrl( self, -1, min=5,max=30, initial=15, size = (45,-1))
        self.text2 = wx.StaticText(self,-1,label='%')

        self.pctpte = wx.SpinCtrl( self, -1, min=5,max=40, initial=20, size = (45,-1))
        self.text3 = wx.StaticText(self,-1,label='% of points clustered in trailing')
        self.pctted = wx.SpinCtrl( self, -1, min=5,max=30, initial=15, size = (45,-1))
        self.text4 = wx.StaticText(self,-1,label='%')
        
        self.text5 = wx.StaticText(self,-1,label='------------ Choose initial control point spacing-------------')
        self.check_equi = wx.CheckBox(self, -1, label = 'Constant Spacing')
        self.check_sder = wx.CheckBox(self, -1, label = 'Cluster by magnitude of 2nd Derivative ')
        
        self.example_text7 = wx.StaticText(self, label='Min')
        self.example_text8 = wx.StaticText(self, label='Max')
        
        self.opt_p0 = wx.CheckBox(self, -1, label = 'Optimize initial control point spacing')
        
        self.sdermax = wx.Slider(self, wx.ID_ANY, size=wx.Size(175,-1),value=20,
                                       style = wx.SL_HORIZONTAL)     
        hbox6 =  wx.BoxSizer( wx.HORIZONTAL )  
        hbox6.Add( self.example_text7, 0, wx.ALIGN_CENTER | wx.ALL, 5 )   
        hbox6.Add( self.sdermax,      0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        hbox6.Add( self.example_text8, 0, wx.ALIGN_CENTER | wx.ALL, 5 )  
        
        self.text6 = wx.StaticText(self,-1,label='------------------ Choose optimizer type -------------------')
        self.check_grad = wx.CheckBox(self, -1, label = 'Gradient Descent')
        self.check_qn = wx.CheckBox(self, -1, label = 'Quasi-Newton')                
           
        self.ok_button = wx.Button( self, wx.ID_ANY, "OK",
                                    wx.DefaultPosition, wx.DefaultSize, 0 )       
        
        hbox1 = wx.BoxSizer( wx.HORIZONTAL )
        hbox1.Add(self.pctple, 0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        hbox1.Add(self.text1,  0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        hbox1.Add(self.pctled, 0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        hbox1.Add(self.text2,  0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
                
        hbox2 = wx.BoxSizer( wx.HORIZONTAL )
        hbox2.Add(self.pctpte, 0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        hbox2.Add(self.text3,  0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        hbox2.Add(self.pctted, 0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        hbox2.Add(self.text4,  0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        
        BoxSizer01.AddSpacer(20)       
        BoxSizer01.Add( self.text0, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.check_auto, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.check_clust, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.AddSpacer(10)
        BoxSizer01.Add(hbox1, 0, wx.ALIGN_CENTER | wx.ALL, 5  )
        BoxSizer01.AddSpacer(5)
        BoxSizer01.Add(hbox2, 0, wx.ALIGN_CENTER | wx.ALL, 5  )
        BoxSizer01.AddSpacer(10)
        BoxSizer01.Add( self.text5, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.check_equi, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.check_sder, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( hbox6, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.opt_p0, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.AddSpacer(10)
        BoxSizer01.Add( self.text6, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.check_grad, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.check_qn, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.AddSpacer(10)
        BoxSizer01.Add(self.ok_button, 0, wx.ALIGN_CENTER | wx.ALL, 5  )

        self.check_auto.Bind(  wx.EVT_CHECKBOX, self.on_auto  )
        self.check_clust.Bind( wx.EVT_CHECKBOX, self.on_clust )
        self.check_equi.Bind(  wx.EVT_CHECKBOX, self.on_eq    )
        self.check_sder.Bind(  wx.EVT_CHECKBOX, self.on_sder  )
        self.check_grad.Bind(  wx.EVT_CHECKBOX, self.on_grad  )
        self.check_qn.Bind(    wx.EVT_CHECKBOX, self.on_qn    )
        self.ok_button.Bind(   wx.EVT_BUTTON,   self.on_close )
        #self.opt_p0.Bind(      wx.EVT_CHECKBOX, self.on_opt   )

        self.check_clust.SetValue( True )
        self.check_sder.SetValue(  True )
        self.check_grad.SetValue(  True )

        self.SetSizer( BoxSizer01 )
        self.Layout()

# ------------------------------------------------------------------------
# Functions here just enable/disable selections
# ------------------------------------------------------------------------
    def on_auto(self,event):
        if self.check_auto.GetValue():
            self.check_clust.SetValue( False )
            self.enab_all( False )
        else:
            self.check_clust.SetValue( True )
            self.enab_all( True )

    def on_clust(self,event):
        if self.check_clust.GetValue():
            self.check_auto.SetValue( False )
            self.enab_all( True )
        else:
            self.check_auto.SetValue( True )
            self.enab_all( False )

    def enab_all( self, val ):
        self.pctple.Enable( val )
        self.pctled.Enable( val )
        self.pctpte.Enable( val )
        self.pctted.Enable( val )

    def on_eq( self,event ):
        if self.check_equi.GetValue():
            self.check_sder.SetValue( False )
        else:
            self.check_sder.SetValue( True )

    def on_sder( self,event ):
        if self.check_sder.GetValue():
            self.check_equi.SetValue( False )
        else:
            self.check_equi.SetValue( True )

    def on_grad( self,event ):
        if self.check_grad.GetValue():
            self.check_qn.SetValue( False )
        else:
            self.check_grad.SetValue( True )

    def on_qn( self,event ):
        if self.check_qn.GetValue():
            self.check_grad.SetValue( False )
        else:
            self.check_qn.SetValue( True )

    def on_close( self, event ):
         self.Hide()


class PointDisWindow(PointDistribution):
      def __init__(self, parent):
        PointDistribution.__init__(self, parent)
        self.parent = parent


############################################################################
class XfoilSettings( wx.Frame ):
    def __init__( self, parent ):
        wx.Frame.__init__ ( self, parent, id = wx.ID_ANY, title = "XFoil", pos = wx.DefaultPosition, size = wx.Size( 300,650 ), style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL )
        self.Bind(wx.EVT_CLOSE, self.on_close)
        BoxSizer01 = wx.BoxSizer( wx.VERTICAL )

        self.text0          = wx.StaticText(self,-1,label='------------ Set Simulation Parameters -------------')

        self.reynolds_text = wx.StaticText(self,label='Reynolds Number')
        self.reynolds_inp   = wx.TextCtrl(self, -1,
            value='1e6',
            size=wx.Size(150,-1),
            style=wx.TE_PROCESS_ENTER)

        self.mach_text = wx.StaticText(self,label='Mach Number')
        self.mach_inp   = wx.TextCtrl(self, -1,
            value='0.2',
            size=wx.Size(150,-1),
            style=wx.TE_PROCESS_ENTER)

        self.ncrit_text = wx.StaticText(self,label='N-crit for Transition Model')
        self.ncrit_inp   = wx.TextCtrl(self, -1,
            value='9',
            size=wx.Size(150,-1),
            style=wx.TE_PROCESS_ENTER)

        self.aoa_text = wx.StaticText(self,label='Angle of Attack')
        self.aoa_inp   = wx.TextCtrl(self, -1,
            value='1',
            size=wx.Size(150,-1),
            style=wx.TE_PROCESS_ENTER)

        self.run_single_button = wx.Button(self, wx.ID_ANY,  "Run Single Angle of Attack",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )     


        self.aoar_text = wx.StaticText(self,label='AoA Range [start, end, interval]')
        self.aoar_inp  = wx.TextCtrl(self, -1,
            value='-4, 4, 1',
            size=wx.Size(150,-1),
            style=wx.TE_PROCESS_ENTER)

        self.name_text = wx.StaticText(self,label='Name (needed for polar)')
        self.name_inp   = wx.TextCtrl(self, -1,
            value='Airfoil Name',
            size=wx.Size(200,-1),
            style=wx.TE_PROCESS_ENTER)
        self.run_polar_button = wx.Button(self, wx.ID_ANY,  "Run Polar",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )  

        self.show_polar_button = wx.Button(self, wx.ID_ANY,  "Show Polars",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )  

        self.ok_button = wx.Button( self, wx.ID_ANY, "OK",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )       

        BoxSizer01.AddSpacer(20)       
        BoxSizer01.Add( self.text0, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.reynolds_text, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.reynolds_inp, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.AddSpacer(5)      
        BoxSizer01.Add( self.mach_text, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.mach_inp, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.AddSpacer(5)      
        BoxSizer01.Add( self.ncrit_text, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.ncrit_inp, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.AddSpacer(5)      
        BoxSizer01.Add( self.aoa_text, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.aoa_inp, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add(self.run_single_button, 0, wx.ALIGN_CENTER | wx.ALL, 5  )
        BoxSizer01.AddSpacer(10)    
        BoxSizer01.Add( self.aoar_text, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.aoar_inp, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.name_text, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add( self.name_inp, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        BoxSizer01.Add(self.run_polar_button, 0, wx.ALIGN_CENTER | wx.ALL, 5  )
        BoxSizer01.AddSpacer(5)
        BoxSizer01.Add(self.show_polar_button, 0, wx.ALIGN_CENTER | wx.ALL, 5  )
        BoxSizer01.AddSpacer(5)
        BoxSizer01.Add(self.ok_button, 0, wx.ALIGN_CENTER | wx.ALL, 5  )
        
        self.ok_button.Bind(wx.EVT_BUTTON, self.on_close )
        self.run_single_button.Bind(wx.EVT_BUTTON, self.run_xfoil_single)
        self.run_polar_button.Bind(wx.EVT_BUTTON, self.run_xfoil_polar)
        self.show_polar_button.Bind(wx.EVT_BUTTON, self.show_polar)


        self.SetSizer( BoxSizer01 )
        self.Layout()

    def show_polar(self, event):
        self.parent.polarwin.Show()

    def run_xfoil_single(self, event):
        self.run_xfoil(event, False)

    def run_xfoil_polar(self, event):
        self.run_xfoil(event, True)

    def write_coords_xfoil(self, event):
        self.Parent.noiter.SetValue( True )
        self.Parent.on_noiter( event )
        self.Parent.gen_bez(event, True)
        if os.path.exists('xfoilcoords_temp'):
            os.remove('xfoilcoords_temp')
        fd = os.open('xfoilcoords_temp', os.O_RDWR|os.O_CREAT )
        xout,yout = [],[]
        xout.extend( self.Parent.xbl[::-1] )
        xout.extend( self.Parent.xbu[1:] )
        yout.extend( self.Parent.ybl[::-1] )
        yout.extend( self.Parent.ybu[1:] )
        for i in range(len(xout)):
            writestr = ''.join([str(xout[i]),'      ', str(yout[i]),'\n'])   
            os.write(fd,writestr)


    # airfoil is a string representing the coordinate file 
    def run_xfoil( self, event, polar ):
        self.write_coords_xfoil(event)
        airfoil = 'xfoilcoords_temp'
        Rey = self.reynolds_inp.GetValue()
        if polar:
            alpha = self.aoar_inp.GetValue()
        else:
            alpha = self.aoa_inp.GetValue()
        mach = self.mach_inp.GetValue()
        ncrit = self.ncrit_inp.GetValue()
        # Initiate subproccess  
        ps = sp.Popen(['xfoil'],
                  stdin=sp.PIPE,
                  stdout=None,
                  stderr=None)
        # define function to give commands to xfoil 
        def issueCmd(cmd,echo=True):
            ps.stdin.write(cmd+'\n')
            if echo: print cmd
            
        # load coordinates and enter OPER mode
        issueCmd( ''.join(['load ', airfoil]) ) 
        issueCmd( ' ' ) 
        issueCmd( 'oper' ) 
        # Set new iteration limit
        issueCmd( 'iter 50' ) 
        issueCmd( 'visc' )
        # Enter Reynolds number   r>
        issueCmd( str(Rey) )
        # mach number 
        issueCmd( ''.join([ 'm', str(mach)  ]) ) 
        issueCmd( 'VPAR' )
        issueCmd( ''.join([ 'N', str(ncrit) ]) )
        issueCmd( ' ' )         
        if polar:
            issueCmd( 'Pacc')
            issueCmd( ' ' )   
            issueCmd( ' ' )   
            issueCmd( ''.join(['Aseq', str(alpha)]))
            issueCmd( 'pwrt' )
            time.sleep( 1.0 )
            issueCmd( ''.join([self.name_inp.GetValue(), '_polar.txt']) )
            issueCmd( ' ' ) 
            issueCmd( ' ' ) 
            issueCmd( 'quit' ) 
            # also write the coordinates to a file
            self.parent.saveline.SetValue(''.join([self.name_inp.GetValue(), '.txt']))
            self.parent.numpoints.SetValue(300)
            self.parent.print_coords(event)
        else:
            #issueCmd( ' ' ) 
            issueCmd( ''.join(['ALFA', str(alpha)]))


        
    def on_close( self, event ): 
         self.Hide()

class XfoilSettingsWindow(XfoilSettings):
      def __init__(self, parent):
        XfoilSettings.__init__(self, parent)
        self.parent = parent                     



class polarwindow(wx.Frame):
    def __init__(self, parent):
        wx.Frame.__init__ ( self, parent, id = wx.ID_ANY, title = "Polar Viewer", pos = wx.DefaultPosition, size = wx.Size( 800,500 ), style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL )
#        self.Parent = parent
        self.Bind(wx.EVT_CLOSE, self.on_close)
        
        # Default figure size, this is part of the frame so when exiting, 
        # the figure does no go away, the frame is just hidden 
        self.fig = Figure(figsize = (14,7), dpi=80)
        self.fig.subplots_adjust(bottom=0.11)
        self.fig.subplots_adjust(top=0.95)
        self.fig.subplots_adjust(right=0.95)
        self.fig.subplots_adjust(left=0.08)
        self.fig.subplots_adjust(wspace=0.15)
        self.axes1 = self.fig.add_subplot(121)
        self.axes2 = self.fig.add_subplot(122)
        self.axes1.set_ylabel('$C_l$')
        self.axes1.set_xlabel('$C_d$')
        self.axes2.set_xlabel('$\\alpha$ (deg)')
        self.labels = []
        
        # Use canvas to embed figure in frame
        self.canvas = FigureCanvas(self, -1, self.fig)
        self.sizer = wx.BoxSizer(wx.VERTICAL)
        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.GROW)

        self.add_polar_button = wx.Button(self, wx.ID_ANY,  "Add Polar",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )  

        self.clear_polar_button = wx.Button(self, wx.ID_ANY,  "Clear",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )  

        hbox1  = wx.BoxSizer( wx.HORIZONTAL )  
        hbox1.Add( self.add_polar_button, wx.ALIGN_CENTER | wx.ALL, 5 )          
        hbox1.Add( self.clear_polar_button,  wx.ALIGN_CENTER | wx.ALL, 5 )  

        self.sizer.Add(hbox1,  0, wx.ALIGN_CENTER | wx.ALL, 5 )
        self.add_polar_button.Bind(wx.EVT_BUTTON, self.add_polar)
        self.clear_polar_button.Bind(wx.EVT_BUTTON, self.clear_polar)


        # connect mouse events to functions  
        # self.fig.canvas.mpl_connect('scroll_event', self.on_scroll )

        self.add_toolbar()  # comment this out for no matplotlib toolbar
        
        self.SetSizer(self.sizer)
        self.Fit()
        #self.Layout()
            
    def add_polar( self,event ):
        wildcard = "All files (*.*)|*.*"
        dialog = wx.FileDialog(None, "Choose a file", os.getcwd(), "", wildcard, wx.OPEN)   
        if dialog.ShowModal() == wx.ID_OK:
            pfile = open( dialog.GetPath(), 'r' )  
            name = os.path.basename(dialog.GetPath())
            self.labels.append(name)
            lines  = pfile.readlines()  
            cl, cd, aoa, ct = [], [], [], 0
            for line in lines:
                if ct > 11:
                    aoa.append(line.split()[0])
                    cl.append(line.split()[1])
                    cd.append(line.split()[2])
                ct+=1
            self.axes1.plot(cd, cl)
            self.axes2.plot(aoa, cl)
            self.axes1.set_ylabel('$C_l$')
            self.axes1.set_xlabel('$C_d$')
            self.axes2.set_xlabel('$\\alpha$ (deg)')
            self.axes2.legend(self.labels, loc=4)
            self.canvas.draw()



    def clear_polar( self,event ):
         self.axes1.cla()
         self.axes2.cla()
         self.canvas.draw()
         self.labels = []
# ----------------------------------------------------------------------
#   Adds standard matplotlib toolbar to frame
# ----------------------------------------------------------------------

    def add_toolbar(self):
        self.toolbar = NavigationToolbar2Wx(self.canvas)
        self.toolbar.Realize()
        if wx.Platform == '__WXMAC__':
            # Mac platform (OSX 10.3, MacPython) does not seem to cope with
            # having a toolbar in a sizer. This work-around gets the buttons
            # back, but at the expense of having the toolbar at the top
            self.SetToolBar(self.toolbar)
        else:
            # On Windows platform, default window size is incorrect, so set
            # toolbar width to figure width.
            tw, th = self.toolbar.GetSizeTuple()
            fw, fh = self.canvas.GetSizeTuple()
            # By adding toolbar in sizer, we are able to put it at the bottom
            # of the frame - so appearance is closer to GTK version.
            # As noted above, doesn't work for Mac.
            self.toolbar.SetSize(wx.Size(fw, th))
            self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)
        # update the axes menu on the toolbar
        self.toolbar.update()


    def showwin( self, event ):
        self.canvas.draw()

    def on_close( self, event ):
        self.Hide() 


class PolarWindow(polarwindow):
      def __init__(self, parent):
        polarwindow.__init__(self, parent)
        self.parent = parent       


############################################################################
# The actual frame for the application 
class MainFrame ( wx.Frame ):
    def __init__( self, parent ):
        wx.Frame.__init__( self, parent, id = wx.ID_ANY, 
                           title = "Bezier Airfoil Smoother", pos = wx.DefaultPosition, 
                           size = wx.Size( 350,760 ),
                           style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL )

        self.havefile = False
        self.canrs    = False
        self.bezcurve = False
        self.cpshown  = False
        self.dershown = False
        self.redraw   = False
        self.printc   = False
        BoxSizer01 = wx.BoxSizer( wx.VERTICAL )
        # add all the wx widgets to this class
        self.fileline    = wx.TextCtrl(self, -1,
            value='coords.txt',
            size=wx.Size(250,-1),
            style=wx.TE_PROCESS_ENTER)
        self.example_text1 = wx.StaticText(self,label='Airfoil Coordinate File')

        self.cfile_button  = wx.Button( self, wx.ID_ANY, "Browse",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )
        self.load_button   = wx.Button( self, wx.ID_ANY, "Load",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )

        self.example_text2 = wx.StaticText(self,label='Select Number of Control Points (>5)')
        self.order         = wx.SpinCtrl( self, -1, min=5, initial=5, size = (45,-1))
        self.load_cp       = wx.Button( self, wx.ID_ANY, "Load Control Pts",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )

        self.example_text4 = wx.StaticText(self,label='Select Number of Points for Airfoil Surface')
        self.numpoints     = wx.SpinCtrl( self, -1, min=100,max=5000, initial=500)
        self.point_button  = wx.Button( self, wx.ID_ANY, "Set Distribution",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )

        self.example_text3 = wx.StaticText(self,label='Optimizer Iterations (>25)')
        self.optits        = wx.SpinCtrl( self, -1, min=25, max=10000, initial=50)

        self.bez_button    = wx.Button(self, wx.ID_ANY,  "Generate Bezier Curves",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )

        self.restart       = wx.CheckBox(self, -1, label = "Restart")
        self.noiter        = wx.CheckBox(self, -1, label = "Don't iterate")


        self.bez_clear     = wx.Button(self, wx.ID_ANY,  "Delete Old Bezier Curves",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )
        self.control_show  = wx.Button(self, wx.ID_ANY,  "Tog Control Points",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )
        self.show_der      = wx.Button(self, wx.ID_ANY,  "Tog Derivatives",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )


        self.example_text5 = wx.StaticText(self,-1,label='Weight for Selected Point')

        self.weight        = wx.SpinCtrl(self, -1, value=str(1), min=0, max=100, size = (45,-1))

        self.resetwt       = wx.Button(self, wx.ID_ANY,  "Reset",
                                       wx.DefaultPosition )  
                                                          

        self.saveline    = wx.TextCtrl(self, -1, value='bez_coords.txt',
            size=wx.Size(150,-1),
            style=wx.TE_PROCESS_ENTER)
        self.save_points  = wx.Button(self, wx.ID_ANY,  "Save Coordinates",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )

        self.savecpline    = wx.TextCtrl(self, -1, value='ConPnts.txt',
            size=wx.Size(150,-1),
            style=wx.TE_PROCESS_ENTER)
        self.save_conpts   = wx.Button(self, wx.ID_ANY,  "Save Control Points",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )

        self.savep3dline    = wx.TextCtrl(self, -1, value='airfoil.p3d',
            size=wx.Size(150,-1),
            style=wx.TE_PROCESS_ENTER)
        self.save_p3d   = wx.Button(self, wx.ID_ANY,  "Save to p3d",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )                                        
                                       
        self.xfoil_button = wx.Button(self, wx.ID_ANY,  "Run XFIOL Sims",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )
        self.reset_button = wx.Button(self, wx.ID_ANY,  "Set Coords to Bez Curve ",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )


        self.inc_te_button = wx.Button(self, wx.ID_ANY,  "Increase TE Thickness",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )
        self.dec_te_button = wx.Button(self, wx.ID_ANY,  "Decrease TE Thickness",
                                       wx.DefaultPosition, wx.DefaultSize, 0 )

        tebox = wx.BoxSizer(wx.HORIZONTAL)
        tebox.Add(self.inc_te_button, wx.ALIGN_CENTER | wx.ALL, 5)
        tebox.Add(self.dec_te_button, wx.ALIGN_CENTER | wx.ALL, 5)

        # Set up how everything is laid out 
        hbox1  = wx.BoxSizer( wx.HORIZONTAL )  
        hbox1.Add( self.cfile_button, wx.ALIGN_CENTER | wx.ALL, 5 )          
        hbox1.Add( self.load_button,  wx.ALIGN_CENTER | wx.ALL, 5 )  

        hbox2  = wx.BoxSizer( wx.HORIZONTAL )  
        hbox2.Add( self.example_text3, 0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        hbox2.Add( self.restart, 0, wx.ALIGN_RIGHT  | wx.ALL, 5 )  
        
        hbox3  = wx.BoxSizer( wx.HORIZONTAL )  
        hbox3.Add( self.example_text5, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        hbox3.Add( self.weight, 0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
        hbox3.Add( self.resetwt, 0, wx.ALIGN_CENTER | wx.ALL, 5 ) 
               
        hbox4  = wx.BoxSizer( wx.HORIZONTAL )  
        hbox4.Add( self.saveline, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        hbox4.AddSpacer(10)
        hbox4.Add( self.save_points, 0, wx.ALIGN_CENTER | wx.ALL, 5 )       

        hbox5  = wx.BoxSizer( wx.HORIZONTAL )  
        hbox5.Add( self.control_show, wx.ALIGN_CENTER | wx.ALL, 5 )
        hbox5.AddSpacer(10)
        hbox5.Add( self.show_der, wx.ALIGN_CENTER | wx.ALL, 5 )     
        
        hbox7  = wx.BoxSizer( wx.HORIZONTAL )  
        hbox7.Add( self.numpoints, wx.ALIGN_CENTER | wx.ALL, 5 )
        hbox7.AddSpacer(10)
        hbox7.Add( self.point_button, wx.ALIGN_CENTER | wx.ALL, 5 )    
        
        
        hbox8  = wx.BoxSizer( wx.HORIZONTAL )  
        hbox8.Add( self.savecpline, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        hbox8.AddSpacer(10)
        hbox8.Add( self.save_conpts,  0, wx.ALIGN_CENTER | wx.ALL, 5 )

        hbox9  = wx.BoxSizer( wx.HORIZONTAL )
        hbox9.Add( self.savep3dline, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        hbox9.AddSpacer(10)
        hbox9.Add( self.save_p3d,  0, wx.ALIGN_CENTER | wx.ALL, 5 )

        hbox10  = wx.BoxSizer( wx.HORIZONTAL )
        hbox10.Add( self.order, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        hbox10.AddSpacer(10)
        hbox10.Add( self.load_cp,  0, wx.ALIGN_CENTER | wx.ALL, 5 )

        hbox11  = wx.BoxSizer( wx.HORIZONTAL )
        hbox11.Add( self.optits, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        hbox11.AddSpacer(10)
        hbox11.Add( self.noiter,  0, wx.ALIGN_CENTER | wx.ALL, 5 )

        hbox12  = wx.BoxSizer( wx.HORIZONTAL )  
        hbox12.Add( self.xfoil_button, 0, wx.ALIGN_CENTER | wx.ALL, 5 )
        hbox12.AddSpacer(2)
        hbox12.Add( self.reset_button,  0, wx.ALIGN_CENTER | wx.ALL, 5 )   

        vbox1  = wx.BoxSizer( wx.VERTICAL )
        #vbox1.AddSpacer(10)
        vbox1.Add(self.example_text1, 0, wx.ALIGN_CENTER | wx.ALL, 1)
        vbox1.Add(self.fileline,      0, wx.ALIGN_CENTER | wx.ALL, 1)
        vbox1.AddSpacer(5)
        vbox1.Add(hbox1,              0, wx.ALIGN_CENTER | wx.ALL, 1)
        vbox1.AddSpacer(10)
        vbox1.Add(self.example_text2, 0, wx.ALIGN_CENTER | wx.ALL, 1)
        vbox1.Add(hbox10,         0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.AddSpacer(5)
        vbox1.Add(self.example_text4, 0, wx.ALIGN_CENTER | wx.ALL, 1)
        vbox1.Add(hbox7,              0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.AddSpacer(5)
        vbox1.Add(hbox2,              0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.Add(hbox11,             0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.AddSpacer(5) 
        vbox1.Add( self.bez_button,   0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.AddSpacer(5)
        vbox1.Add(self.bez_clear,     0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.AddSpacer(5)
        vbox1.Add(hbox5,              0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.AddSpacer(5)  
        vbox1.Add(tebox,              0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.AddSpacer(30) 
        vbox1.Add(hbox3,              0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.AddSpacer(20) 
        vbox1.Add(hbox4,              0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.Add(hbox8,              0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.Add(hbox9,              0, wx.ALIGN_CENTER | wx.ALL, 1 )
        vbox1.AddSpacer(30) 
        vbox1.Add(hbox12,  0, wx.ALIGN_CENTER | wx.ALL, 1 )
        
        BoxSizer01.Add( vbox1, 0, wx.ALIGN_CENTER | wx.ALL, 25 )

        self.cfile_button.Bind( wx.EVT_BUTTON,   self.sel_file     )
        self.load_button.Bind(  wx.EVT_BUTTON,   self.on_load      )
        self.bez_button.Bind(   wx.EVT_BUTTON,   self.opt_bez      )
        self.weight.Bind(       wx.EVT_SPINCTRL, self.chgwt        )
        self.bez_clear.Bind(    wx.EVT_BUTTON,   self.rm_bcurves   )
        self.control_show.Bind( wx.EVT_BUTTON,   self.show_cpts    )
        self.save_points.Bind(  wx.EVT_BUTTON,   self.print_coords )
        self.show_der.Bind(     wx.EVT_BUTTON,   self.comp_der     )
        self.point_button.Bind( wx.EVT_BUTTON,   self.set_dis      )
        self.save_conpts.Bind(  wx.EVT_BUTTON,   self.print_cpts   )
        self.resetwt.Bind(      wx.EVT_BUTTON,   self.reset_wt     )
        self.save_p3d.Bind(     wx.EVT_BUTTON,   self.on_p3d       )
        self.load_cp.Bind(      wx.EVT_BUTTON,   self.on_loadcp    )
        self.noiter.Bind(       wx.EVT_CHECKBOX, self.on_noiter    )
        self.xfoil_button.Bind( wx.EVT_BUTTON,   self.open_xfoil   )
        self.reset_button.Bind( wx.EVT_BUTTON,   self.on_reset     )
        self.inc_te_button.Bind( wx.EVT_BUTTON,  self.inc_te       )
        self.dec_te_button.Bind( wx.EVT_BUTTON,  self.dec_te       )


        self.SetSizer( BoxSizer01 ) 
        self.Layout()

# ------------------------------------------------------------------------
# Show the window that allows users to select points
# ------------------------------------------------------------------------
    def set_dis( self,event ):
        self.pointwin.Show()

    def open_xfoil( self,event ):
        self.xfoilwin.Show() 

    def inc_te( self,event ):
        self.move_te(event, True)

    def dec_te( self,event ):
        self.move_te(event, False)

    def move_te( self,event,inc ):
        if inc:
            self.ycu[-1] = self.ycu[-1] + 0.001
            self.ycl[-1] = self.ycl[-1] - 0.001
        else:
            self.ycu[-1] = self.ycu[-1] - 0.001
            self.ycl[-1] = self.ycl[-1] + 0.001
        self.gen_bez(event)
        self.plotwin.axes.cla()
        self.cpshown = False
        self.show_cpts(event)
        self.plotwin.axes.plot(self.xu, self.yu, 'ko') 
        self.plotwin.axes.plot(self.xl, self.yl, 'ko') 
        self.plotwin.axes.plot(self.xu,self.yu,'g--',self.xl,self.yl,'g--')  
        self.plotwin.axes.plot(self.xbu,self.ybu,'b',self.xbl,self.ybl,'b')
        self.plotwin.axes.set_xlim([0.90, 1.05])
        self.plotwin.axes.set_ylim([-0.02, 0.02])
        self.plotwin.canvas.draw()


    def sel_file( self,event ):
	wildcard = "All files (*.*)|*.*"
	dialog = wx.FileDialog(None, "Choose a file", os.getcwd(), "", wildcard, wx.OPEN)
	if dialog.ShowModal() == wx.ID_OK:
		self.fileline.SetValue(dialog.GetPath())

# ------------------------------------------------------------------------
# Function that reads selected file and loads the airfoil coordinates to the GUI
# ------------------------------------------------------------------------
    def on_load( self,event ):
        self.plotwin.Show()
        self.havefile = False
        self.plotwin.pointsel = False
        self.cpshown = False
        self.bcurves = []
        try:
            self.coordfile = open( self.fileline.GetValue(), 'r' )
            self.havefile = True
        except:
            print "Coordinate file not found"
        # load full coordinate set, later split between upper and lower surface
        if self.havefile:
           self.xfull,self.yfull = [],[]
           lines = self.coordfile.readlines()
           for line in lines:
              # do some checking to make sure we are loading only coordinates
              temp = list(line)
              for i in range(len(temp)):
                  if temp[i] == ',':
                     temp[i] = ' '
              line2 = ''.join(temp)
              if len(line2.split()) > 0:
                 if self.is_number( line2.split()[0] ):
                    self.xfull.append( float(line2.split()[0]) )
                    self.yfull.append( float(line2.split()[1]) )
              	    #print line.split()[0]
           self.plotwin.axes.cla()
           # now try and split the arrays into the upper and lower surface
           self.split_coords()
           self.plotwin.axes.plot(self.xu, self.yu, 'ko')
           self.plotwin.axes.plot(self.xl, self.yl, 'ko')
           self.plotwin.axes.plot(self.xu,self.yu,'g--',self.xl,self.yl,'g--')
           self.plotwin.axes.set_aspect( 'equal', 'datalim' )
           self.plotwin.canvas.draw()
           self.wtu = [1.0 for i in range(len(self.xu))]
           self.wtl = [1.0 for i in range(len(self.xl))]
           # Flag that we cannot restart this case
           self.canrs = False
           self.noiter.SetValue( False )
           self.optits.Enable( True )

# ------------------------------------------------------------------------
# Function that reads control point file and sets those
# ------------------------------------------------------------------------
    def on_loadcp( self,event ):
        wildcard = "All files (*.*)|*.*"
        dialog = wx.FileDialog(None, "Choose a file", os.getcwd(), "", wildcard, wx.OPEN)
        if dialog.ShowModal() == wx.ID_OK:
           self.havefile = True
           self.plotwin.pointsel = False
           self.cpshown = False
           self.plotwin.Show()
           self.bcurves = []
           cpfile = open( dialog.GetPath(), 'r' )
           self.fileline.SetValue(dialog.GetPath())
           lines  = cpfile.readlines()
           cpxfull,cpyfull = [],[]
           N = int(lines[0])
           for i in range(1,(N*2 + 1)):
               cpxfull.append( float(lines[i].split()[0]) )
               cpyfull.append( float(lines[i].split()[1]) )
           self.Poutu = [[0.0 for i in range(N) ] for j in range(2) ]
           self.Poutl = [[0.0 for i in range(N) ] for j in range(2) ]
           self.Poutu[0][:], self.Poutu[1][:] = cpxfull[:N], cpyfull[:N]
           self.Poutl[0][:], self.Poutl[1][:] = cpxfull[N:], cpyfull[N:]
           self.order.SetValue( N )
           self.noiter.SetValue( True )
           self.on_noiter( event )
           self.canrs = True
           self.restart.SetValue( True )
           # Now we are loading the coordinates from the control point file
           self.xfull,self.yfull = [],[]
           lines2 = lines[(N*2+1):]
           for line in lines2:
               self.xfull.append( float(line.split()[0]) )
               self.yfull.append( float(line.split()[1]) )
           self.plotwin.axes.cla()
           # now try and split the arrays into the upper and lower surface
           self.split_coords()
           self.show_cpts( event )
           self.plotwin.axes.plot(self.xu, self.yu, 'ko')
           self.plotwin.axes.plot(self.xl, self.yl, 'ko')
           self.plotwin.axes.plot(self.xu,self.yu,'g--',self.xl,self.yl,'g--')
           self.plotwin.axes.set_aspect( 'equal', 'datalim' )
           self.plotwin.canvas.draw()
           self.wtu = [1.0 for i in range(len(self.xu))]
           self.wtl = [1.0 for i in range(len(self.xl))]

# ------------------------------------------------------------------------
# Function that is called when the no iteration check mark is selected
# ------------------------------------------------------------------------
    def on_noiter( self,event ):
        if self.noiter.GetValue():
            self.optits.Enable( False )
            self.itopt = 0
        else:
            self.optits.Enable( True )


# ------------------------------------------------------------------------
# Function that changes weight of a selected points
# ------------------------------------------------------------------------
    def chgwt( self,event ):
        if (self.plotwin.pointsel and self.havefile):
            if self.plotwin.u_or_l == 'u':
                self.wtu[self.plotwin.pind] = self.weight.GetValue()
            else:
                self.wtl[self.plotwin.pind] = self.weight.GetValue()


# ------------------------------------------------------------------------
# Function that sets weight of all points to 1.0
# ------------------------------------------------------------------------
    def reset_wt( self,event ):
        if self.havefile:
           self.wtu = [1.0 for i in range(len(self.xu))]
           self.wtl = [1.0 for i in range(len(self.xl))]
           self.weight.SetValue(1)


# ------------------------------------------------------------------------
# Function that tries to evenly divide points by curvilinear distance 
# ------------------------------------------------------------------------           
    def split_pts( self, is_xfoil ):
        if self.havefile:
            if is_xfoil:
                npts = 300
            else:
                npts   = self.numpoints.GetValue() 
            if self.canrs and self.noiter.GetValue() == False: #If we have a curve already, use those coordinates
                udis,ldis = self.distform( self.xbu,self.ybu ),self.distform( self.xbl,self.ybl )
            else:
                udis,ldis = self.distform( self.xu,self.yu ),self.distform( self.xl,self.yl )
            upct   = udis/(udis+ldis)
            print upct
            self.ptsu = int(round((upct*npts)))
            self.ptsl = npts - self.ptsu
            print self.ptsu, self.ptsl


    def opt_bez( self, event ):
        if self.pointwin.opt_p0.GetValue():
            minnorm = 9999.9
            for i in range(10):
                self.pointwin.sdermax.SetValue( (i+1)*10.0 )
                norm = self.gen_bez( event )
                if norm < minnorm: minnorm,ind = norm,i
            self.rm_bcurves(event)
            self.pointwin.sdermax.SetValue( (ind+1)*10.0 )
            norm = self.gen_bez( event )
            self.pointwin.opt_p0.SetValue(False)
        else:
            norm = self.gen_bez( event )

# ------------------------------------------------------------------------     
# Function that actually calls the fortran routine to generate the bezier curves 
# ------------------------------------------------------------------------       
    def gen_bez( self, event, is_xfoil=False ):
        self.plotwin.Show()
        self.split_pts(is_xfoil)
        if self.havefile:
           self.bezcurve = True
           self.N = self.order.GetValue() 
           if (self.noiter.GetValue() == False and self.redraw == False):
               self.itopt = self.optits.GetValue()
           # This is called when the print coords function is called

           if self.printc:
               self.itopt  = 0
               mpts        = 250000
               self.printc = False
               self.redraw = True
           else: mpts =10000

           # Look for initial estimate for control points, upper surface first
           Pinu    = [[0.0 for i in range(self.N)] for j in range(2)]
           Pinl    = [[0.0 for i in range(self.N)] for j in range(2)]

           # if we are using the second derivative to space CPs
           if self.pointwin.check_sder.GetValue():
               self.get_p0()
               Pinu = [[0.0 for i in range(len(self.Pinux))] for j in range(2)]
               Pinl = [[0.0 for i in range(len(self.Pinlx))] for j in range(2)]
               Pinu[0][:] = self.Pinux 
               Pinl[0][:] = self.Pinlx
               Pinu[1][0] = self.yu[0]
               Pinu[1][1] = numpy.amax(self.yu)
               Pinl[1][0] = self.yl[0]
               Pinl[1][1] = numpy.amin(self.yl)
               for i in range(len(self.Pinux)-3):
                   Pinu[1][i+2] = 1.2*numpy.interp(self.Pinux[i+2],self.xu,self.yu )
               for i in range(len(self.Pinlx)-3):
                   Pinl[1][i+2] = 1.2*numpy.interp(self.Pinlx[i+2],self.xl,self.yl )
           else:  #even spacing
               xmin,xmax = self.xu[0], self.xu[-1]
               Pinu[0][1]  = self.xu[0]
               Pinu[1][1]  = numpy.amax(self.yu)
               initsp  =  (xmax-xmin)/(self.N-2)
               for i in range(self.N-3):
                   Pinu[0][i+2] = xmin + initsp*(i+1)
                   Pinu[1][i+2] = 1.1*numpy.interp((xmin+ initsp*(i+1)),self.xu,self.yu )
               #--------------------------------------------------------------------------
               xmin,xmax = self.xl[0], self.xl[-1]
               Pinl[0][1]  = self.xl[0]
               Pinl[1][1]  = numpy.amin(self.yl)
               initsp  =  (xmax-xmin)/(self.N-2)
               for i in range(self.N-3):
                   Pinl[0][i+2] = xmin + initsp*(i+1)
                   Pinl[1][i+2] = 1.1*numpy.interp((xmin + initsp*(i+1)),self.xl,self.yl )
           # End Coordinates
           Pinu[0][-1] = self.xu[-1]
           Pinu[1][-1] = self.yu[-1]
           Pinl[0][-1] = self.xl[-1]
           Pinl[1][-1] = self.yl[-1]

           # see if we are using existing control points
           if (((self.restart.GetValue() or self.noiter.GetValue()) and self.canrs)
               or self.redraw):
               Pinl = self.Poutl
               Pinu = self.Poutu
               self.redraw = False

           le_scale  = 0.0

           self.load_sp()
           Hk = numpy.identity(self.N*2)

           if self.pointwin.check_grad.GetValue():
               otyp = 1
           else:
               otyp = 0

           self.Poutu,self.Poutl,self.xbu,self.ybu,self.xbl,self.ybl,norm = bezier_opt_main(self.ptsu,
                                             self.ptsl,self.itopt,mpts,otyp,le_scale,Hk,self.xu,self.yu,
                                             self.xl,self.yl,self.wtu,self.wtl,self.pdis,Pinu,Pinl)

           self.plotwin.axes.plot(self.xbu,self.ybu,'b',self.xbl,self.ybl,'b')
           self.plotwin.axes.set_aspect( 'equal', 'datalim' )
           self.plotwin.axes.set_xlabel('$x/c$')
           self.plotwin.axes.set_ylabel('$y/c$')
           self.plotwin.canvas.draw() 
           # save the index of the curves 
           temp = len(self.plotwin.axes.lines) - 1
           self.bcurves.extend([temp-3,temp-2,temp-1,temp])
           self.canrs = True
           # redraw the control points if they are shown
           if self.cpshown:
                self.show_cpts( event )
                self.show_cpts( event )
           return norm


    def distform( self,x,y ):
        temp = 0.0
        for i in range(len(x)-1):
            ds = ( (x[i+1] - x[i])**2 + (y[i+1] - y[i])**2 )**0.5
            temp = temp + ds
        return temp

    def compders( self,x,y ):
        dy,dx   = numpy.diff( y ), numpy.diff( x )
        dydx    = numpy.divide(dy,dx)
        ddy,ddx = numpy.diff( dydx ), numpy.diff( x[:-1] )
        dydx2   = numpy.divide(ddy,ddx)
        return dydx,dydx2

    def compmag( self,x,y,dydx2,max2d ):
        tot = 0.0
        for i in range(len(dydx2)):
            dydx2[i] = abs(dydx2[i])
            if dydx2[i] > max2d: dydx2[i] = max2d
            ds = ((x[i+1]-x[i])**2 + (y[i+1]-y[i])**2)**0.5
            tot += dydx2[i]*ds
        return tot


    def setpts( self,x,y,dydx2,tot,N ):
        # First two x-coords are the same
        P0     = [ x[0], x[0] ]
        yder   = [0.0]
        for i in range(len(x)-2):
            ds = ((x[i+1]-x[i])**2 + (y[i+1]-y[i])**2)**0.5
            temp = ds*abs(dydx2[i]) + yder[i]
            yder.append(temp)
        ptsrm  = N - 3
        thresh = (0.96*yder[-1])/ptsrm
        xth    = [thresh]
        for i in range(ptsrm-1):
            xth.append( xth[i] + thresh )
        xintp  = numpy.interp(xth, yder, x[:-1] )
        P0.extend( xintp )
        P0.append(x[-1])
        return P0

# ------------------------------------------------------------------------
# Function that tries to divide initial control points
# ------------------------------------------------------------------------
    def get_p0( self ):
        # set a max for the second derivative
        max2d  = (self.pointwin.sdermax.GetValue() / 5.0)
        # compute derivatives
        dydxu, dydx2u = self.compders( self.xu, self.yu )
        dydxl, dydx2l = self.compders( self.xl, self.yl )
        utot          = self.compmag( self.xu, self.yu, dydx2u, max2d)
        ltot          = self.compmag( self.xl, self.yl, dydx2l, max2d)
        self.Pinux = self.setpts( self.xu,self.yu,dydx2u,utot,self.N )
        self.Pinlx = self.setpts( self.xl,self.yl,dydx2l,ltot,self.N )


# ------------------------------------------------------------------------
# Function that loads values for point distribution from GUI into array
# ------------------------------------------------------------------------
    def load_sp( self ):
        self.pdis = [1.0 for i in range(5)]
        if self.pointwin.check_auto.GetValue():
            self.pdis[0] = 0.0
        self.pdis[1] = self.pointwin.pctple.GetValue()/100.0
        self.pdis[2] = self.pointwin.pctpte.GetValue()/100.0
        self.pdis[3] = self.pointwin.pctled.GetValue()/100.0
        self.pdis[4] = self.pointwin.pctted.GetValue()/100.0


# ------------------------------------------------------------------------
# Function that removes all drawn bezier curves
# ------------------------------------------------------------------------
    def rm_bcurves( self,event ):
        if self.cpshown:
            self.del_cpts()
        for i in reversed(range(len(self.plotwin.axes.lines))):
            if i > 3:
               del self.plotwin.axes.lines[i]
        self.plotwin.pointsel = False
        self.bezcurve = False
        if self.cpshown:
            self.cpshown = False
            self.show_cpts( event )
        self.plotwin.canvas.draw()

# ------------------------------------------------------------------------
# Function that draws control points
# ------------------------------------------------------------------------
    def show_cpts( self,event ):
        self.plotwin.Show()
        if self.cpshown:
            self.del_cpts()
            self.cpshown = False
        else:
            if (self.canrs):
                self.xcu,self.ycu = self.Poutu[0][:], self.Poutu[1][:]
                self.xcl,self.ycl = self.Poutl[0][:], self.Poutl[1][:]
                self.plotwin.axes.plot(self.xcu,self.ycu,ls='--', c='#666666',
                      marker='x', mew=2, mec='#204a87' )
                self.plotwin.axes.plot(self.xcl,self.ycl,ls='--', c='#666666',
                      marker='x', mew=2, mec='#204a87' )
                self.plotwin.canvas.draw()
                temp = len( self.plotwin.axes.lines ) - 1
                self.cpcurves = [temp,temp-1]
                self.cpshown = True


# ------------------------------------------------------------------------
# Function that removes control points from axis
# ------------------------------------------------------------------------
    def del_cpts( self ):
         for j in range(len(self.cpcurves)):
             ind = self.cpcurves[j]
             if len( self.bcurves ) > 0:
                for i in range(len(self.bcurves)):
                    if self.bcurves[i] > ind:
                        self.bcurves[i] = self.bcurves[i] - 1
             del self.plotwin.axes.lines[ind]
             self.plotwin.canvas.draw()

# ------------------------------------------------------------------------
# Function that shows the first and second derivative on the axis
# ------------------------------------------------------------------------
    def comp_der( self,event ):
        self.plotwin.Show()
        if self.dershown:
            self.plotwin.axes.cla()
            self.plotwin.axes.plot(self.xu, self.yu, 'ko')
            self.plotwin.axes.plot(self.xl, self.yl, 'ko')
            self.plotwin.axes.plot(self.xu,self.yu,'g--',self.xl,self.yl,'g--')
            self.plotwin.axes.plot(self.xbu,self.ybu,'b',self.xbl,self.ybl,'b')
            self.plotwin.axes.set_aspect( 'equal', 'datalim' )
            if self.cpshown:
                self.cpshown = False
                self.show_cpts( event )
            self.plotwin.canvas.draw()
            self.dershown = False
            self.pointsel = False
        else:
            if self.havefile:
                dydxu,dydx2u = self.compders( self.xbu, self.ybu )
                dydxl,dydx2l = self.compders( self.xbl, self.ybl )
                self.plotwin.axes.cla()
                self.plotwin.axes.plot(self.xbu[:-1],dydxu,'g',  self.xbl[:-1],dydxl,'b')
                self.plotwin.axes.plot(self.xbu[:-2],dydx2u,'g--', self.xbl[:-2],dydx2l, 'b--')
                labels = ['$dy/dx$ (upper)', '$dy/dx$ (lower)','$d^2 y/dx^2$ (upper)', '$d^2y/dx^2$ (lower)']
                self.plotwin.axes.legend( labels )
                self.plotwin.axes.set_ylim( [-4,4] )
		self.plotwin.axes.set_xlim( [0,1] )
		self.plotwin.axes.set_aspect( 'auto', 'datalim')
                self.plotwin.canvas.draw()
                self.dershown = True


    def on_reset( self,event ):
        if self.canrs:
            self.noiter.SetValue( True )
            self.on_noiter( event )
            self.numpoints.SetValue(100)
            self.gen_bez(event)
            self.xu = self.xbu
            self.yu = self.ybu
            self.xl = self.xbl
            self.yl = self.ybl
            self.wtu = [1.0 for i in range(len(self.xu))]
            self.wtl = [1.0 for i in range(len(self.xl))]
            self.numpoints.SetValue(500)
            # use the derivative function 
            self.dershown = True
            self.cpcurves = []
            self.comp_der(event)

# ------------------------------------------------------------------------
# Function saves the current coordinates to a file
# ------------------------------------------------------------------------
    def print_coords( self,event ):
        if self.canrs:
            savef = False
            filetitle = self.saveline.GetValue()
            if os.path.exists(filetitle):
                dlg = wx.MessageDialog(self,
                "File Exits, Overwrite?",
                "Confirm Overwrite", wx.OK|wx.CANCEL|wx.ICON_QUESTION)
                result = dlg.ShowModal()
                dlg.Destroy()
                if result == wx.ID_OK:
                    os.remove(filetitle)
                    savef = True
            else:
                savef = True
            if savef == True:
                self.printc = True
                self.gen_bez(event)
                fd        = os.open(filetitle, os.O_RDWR|os.O_CREAT )
                xout,yout = [],[]
                xout.extend( self.xbl[::-1] )
                xout.extend( self.xbu[1:] )
                yout.extend( self.ybl[::-1] )
                yout.extend( self.ybu[1:] )
                for i in range(len(xout)):
                    writestr = ''.join([str(xout[i]),'      ', str(yout[i]),'\n'])
                    os.write(fd,writestr)



# ------------------------------------------------------------------------
# Function saves the current control points to a file
# ------------------------------------------------------------------------
    def print_cpts( self,event ):
        if self.canrs:
            savef = False
            filetitle = self.savecpline.GetValue()
            if os.path.exists(filetitle):
                dlg = wx.MessageDialog(self,
                "File Exits, Overwrite?",
                "Confirm Overwrite", wx.OK|wx.CANCEL|wx.ICON_QUESTION)
                result = dlg.ShowModal()
                dlg.Destroy()
                if result == wx.ID_OK:
                    os.remove(filetitle)
                    savef = True
            else:
                savef = True
            if savef == True:
                fd        = os.open(filetitle, os.O_RDWR|os.O_CREAT )
                # Write the number of control points as header
                writestr = ''.join([str(self.N),'\n'])
                os.write( fd,writestr )
                xout,yout = [],[]
                xout.extend( self.Poutu[0] )
                yout.extend( self.Poutu[1] )
                xout.extend( self.Poutl[0] )
                yout.extend( self.Poutl[1] )
                for i in range(len(xout)):
                    writestr = ''.join([str(xout[i]),'      ', str(yout[i]),'\n'])
                    os.write(fd,writestr)
                # Now write out the coordinates used with these control points
                xout,yout = [],[]
                xout.extend( self.xl[::-1] )
                xout.extend( self.xu[1:] )
                yout.extend( self.yl[::-1] )
                yout.extend( self.yu[1:] )
                for i in range(len(xout)):
                    writestr = ''.join([str(xout[i]),'      ', str(yout[i]),'\n'])
                    os.write(fd,writestr)


# ------------------------------------------------------------------------
# Function saves the current coordinates to a p3d file
# ------------------------------------------------------------------------
    def on_p3d( self,event ):
        if self.canrs:
            savef     = False
            p3dtitle  = self.savep3dline.GetValue()
            if os.path.exists(p3dtitle):
                dlg = wx.MessageDialog(self,
                "File Exits, Overwrite?",
                "Confirm Overwrite", wx.OK|wx.CANCEL|wx.ICON_QUESTION)
                result = dlg.ShowModal()
                dlg.Destroy()
                if result == wx.ID_OK:
                    os.remove(p3dtitle)
                    savef = True
            else:
                savef = True
            if savef == True:
                tempname = self.saveline.GetValue()
                self.saveline.SetValue('tempfile.xy')
                self.print_coords(event)
                s = Popen(['p3dtrans', '-formi', 'xy', '-i', 'tempfile.xy', '-o', p3dtitle])
                s.communicate()
                self.saveline.SetValue(tempname)
                os.remove('tempfile.xy')



# ------------------------------------------------------------------------
# Function that tries to break up airfoil coordinates into upper and lower surface
# ------------------------------------------------------------------------     
    def split_coords(self):  
           xmin,xmax = numpy.amin( self.xfull ), numpy.amax( self.xfull )
           ind = 0
           mininds,maxinds = [],[]
           for i in range(len(self.xfull)):
               if self.xfull[i] == xmin: mininds.append(i)
               if self.xfull[i] == xmax: maxinds.append(i)
           for x in self.xfull:
              if x == xmin:
                 if ind < len(self.xfull):
                    if self.yfull[ind + 1] > self.yfull[ind]:
                       if ind == 0:
                           self.xu = self.xfull[:min(maxinds)+1]
                           self.xl = self.xfull[min(maxinds)+1:]
                           self.yu = self.yfull[:min(maxinds)+1]
                           self.yl = self.yfull[min(maxinds)+1:]
                       else:
                           self.xu = self.xfull[ind:]
                           self.xl = self.xfull[0:ind+1]
                           self.yu = self.yfull[ind:]
                           self.yl = self.yfull[0:ind+1]
                       if self.xl[0] > self.xl[1]:
                           self.yl = self.yl[::-1]
                           self.xl = self.xl[::-1]
                 if ind > 0:
                    if self.yfull[ind - 1] > self.yfull[ind]:
                       self.xu = self.xfull[0:ind+1]
                       self.xl = self.xfull[ind:]
                       self.yu = self.yfull[0:ind+1]
                       self.yl = self.yfull[ind:]
                       self.xu = self.xu[::-1]
                       self.yu = self.yu[::-1]
              ind = ind + 1
           if ((self.xu[0] == self.xu[1]) and
               (self.yu[0] == self.yu[1])):
                  del self.xu[0]
                  del self.yu[0]
           if ((self.xl[0] == self.xl[1]) and
               (self.yl[0] == self.yl[1])):
                  del self.xl[0]
                  del self.yl[0]

    def is_number(self,s):
        try:
        	float(s)
        	return True
        except ValueError:
	        return False



class MainApp(MainFrame):
    def __init__(self, parent):
        MainFrame.__init__(self, parent)
        bSizer1 = wx.BoxSizer( wx.VERTICAL )
        self.plotwin  = PlotWindow(self)
        self.pointwin = PointDisWindow(self)
        self.xfoilwin = XfoilSettingsWindow(self)
        self.polarwin = PolarWindow(self)
        self.xfoilwin.Hide()
        self.polarwin.Hide()
        self.plotwin.Hide() 
        self.pointwin.Hide() 
        self.SetSizer(bSizer1)
        self.Layout()



if __name__ == "__main__":
    app = wx.PySimpleApp()
    app.frame = MainApp(None)
    app.frame.Show()
    app.MainLoop()
